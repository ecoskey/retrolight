#pragma kernel Lighting

#include "../ShaderLibrary/Common.hlsl"
#include "../ShaderLibrary/GBuffer.hlsl"
#include "../ShaderLibrary/Light.hlsl"
#include "../ShaderLibrary/Lighting.hlsl"
#include "../ShaderLibrary/Viewport.hlsl"
#include "../ShaderLibrary/Edges.hlsl"
#include "../ShaderLibrary/Filtering.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
#define BUCKET_SIZE 32
#define TILE_BUCKET_COUNT (MAX_LIGHTS / BUCKET_SIZE)

uint LightCount;
StructuredBuffer<Light> Lights;
ByteAddressBuffer CullingResults;

RW_TEXTURE2D(float4, FinalColorTex);

struct ThreadInfo {
    uint2 id : SV_GroupID;
    uint index : SV_GroupIndex;
    uint2 dispatchId : SV_DispatchThreadID;
    uint2 subId : SV_GroupThreadID;
};

Surface GetSurfaceGBuffer(uint2 pos) {
    Surface surface;
    float4 albedo = LoadAlbedo(pos);
    surface.color = albedo.rgb;
    surface.alpha = albedo.a;
    surface.position = WorldSpaceFromDepthCompute(pos, Resolution.zw);
    surface.normal = LoadNormal(pos);
    const float4 attributes = LoadAttributes(pos);
    surface.metallic = attributes.x;
    surface.smoothness = attributes.y;
    surface.depthEdgeStrength = attributes.z;
    surface.normalEdgeStrength = attributes.w;
    surface.viewDir = normalize(_WorldSpaceCameraPos - surface.position);
    return surface;
}

float3 GetLighting(Surface surface, Light light, uint2 pos) {
    const BrdfParams params = GetBrdfParams(surface);
    return DirectBRDF(surface, params, light, pos);
}

[numthreads(8, 8, 1)]
void Lighting(ThreadInfo input) {
    if (IsPixelOOB(input.dispatchId)) return;
    const uint globalTileOffset = TileIndex(input.id) * TILE_BUCKET_COUNT;
    const Surface surface = GetSurfaceGBuffer(input.dispatchId);
    float3 accLight = 0;
    UNITY_LOOP
    for (uint i = 0; i * BUCKET_SIZE < LightCount; i++) { 
        const uint lightsOffset = i * BUCKET_SIZE;
        uint bucket = CullingResults.Load(globalTileOffset + i);
        while (bucket != 0) {
            const uint firstLightIndex = firstbitlow(bucket);
            ClearBit(bucket, firstLightIndex);
            const Light light = Lights[lightsOffset + firstLightIndex];
            accLight += GetLighting(surface, light, input.dispatchId);
        }
    }
    FinalColorTex[input.dispatchId] = float4(accLight, surface.alpha);
}
