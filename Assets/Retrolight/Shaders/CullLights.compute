#pragma kernel CullLights

#include "../ShaderLibrary/GBuffer.hlsl"
#include "../ShaderLibrary/Tiling.hlsl"
#include "../ShaderLibrary/Light.hlsl"

#define BUCKET_SIZE 32
#define TILE_BUCKET_COUNT (MAX_LIGHTS / BUCKET_SIZE)

RWByteAddressBuffer AllTiles;

groupshared uint tile[MAX_LIGHTS / BUCKET_SIZE];
groupshared uint uMinDepth = 0xFFFFFFFF;
groupshared uint uMaxDepth = 0;
groupshared uint depthMask = 0;

struct ThreadInfo {
    uint2 id : SV_GroupID;
    uint2 subId : SV_GroupThreadID;
    uint2 dispatchId : SV_DispatchThreadID;
    uint index : SV_GroupIndex;
};

[numthreads(TILE_DIMENSION, TILE_DIMENSION, 1)]
void CullLights(ThreadInfo input) {
    //sample depth buffer at all location in tile, and InterlockedMin/Max with respective floats
    //sync group threads
    //get depthMask index of depth and use InterlockedOr to write to the mask
    const float2 uv = PixelToUV(input.dispatchId);

    //look into parallel reduction rather than atomics
    const float depth = Sample01DepthLOD(uv, 0);
    InterlockedMin(uMinDepth, asuint(depth));
    InterlockedMax(uMaxDepth, asuint(depth));
    GroupMemoryBarrierWithGroupSync();

    #if UNITY_REVERSED_Z
    const float fMinDepth = asfloat(uMaxDepth);
    const float fMaxDepth = asfloat(uMinDepth);
    #else
    const float fMinDepth = asfloat(uMinDepth);
    const float fMaxDepth = asfloat(uMaxDepth);
    #endif
    
    const float depthRangeRecip = float(BUCKET_SIZE) / (fMaxDepth - fMinDepth);
    const uint depthMaskIndex = max(0, min(BUCKET_SIZE - 1, floor((depth - fMinDepth) * depthRangeRecip)));
    InterlockedOr(depthMask, 1 << depthMaskIndex);

    uint i;
    const uint subIndex = input.subId.y * TILE_DIMENSION + input.subId.y;

    UNITY_UNROLL //should be fine unless max light count is absolutely absurd (loop only runs once with 1024 lights)
    for (i = subIndex; i < TILE_BUCKET_COUNT; i += TILE_DIMENSION * TILE_DIMENSION) {
        tile[i] = 0; 
    }

    GroupMemoryBarrierWithGroupSync();
    
    //oops, get linear group index instead of groupIdx
    for (i = subIndex; i < MAX_LIGHTS; i += TILE_DIMENSION * TILE_DIMENSION) {
        uint bucketIndex = i / BUCKET_SIZE;
        uint bitIndex = i % BUCKET_SIZE;

        /* CUlL THE LIGHTS
         * loop through lights one thread group at a time
         * construct culling structure for lights
         * fill light depth mask
         * test against AABB if ortho, frustum if perspective
         * test if (lightMask & geometryMask) > 0 to decide if light affects the frustum
         * insert into bit array with tileLightmask[lightIndex / 32] |= 1 << lightIndex % 32
         * ^^this but interlockedOr
         */
    }

    GroupMemoryBarrierWithGroupSync();

    const uint globalTileOffset = input.index * TILE_BUCKET_COUNT;
    //loop to copy groupshared light bit array to big, concatenated global one :))))
    UNITY_UNROLL
    for (i = subIndex; i < TILE_BUCKET_COUNT; i += TILE_DIMENSION * TILE_DIMENSION) {
        AllTiles.Store(globalTileOffset + i, tile[i]); //index is incorrect, should be linear tile index + i
    }
}
