#pragma kernel LightingPass

#include "../ShaderLibrary/GBuffer.hlsl"
#include "../ShaderLibrary/Light.hlsl"
#include "../ShaderLibrary/Tiling.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
#define BUCKET_SIZE 32
#define TILE_BUCKET_COUNT (MAX_LIGHTS / BUCKET_SIZE)

uint LightCount;
StructuredBuffer<Light> Lights;
RWByteAddressBuffer AllTiles;

RWTexture2D<float4> FinalColor;

struct ThreadInfo {
    uint2 id : SV_GroupID;
    uint index : SV_GroupIndex;
    uint2 dispatchId : SV_DispatchThreadID;
    uint2 subId : SV_GroupThreadID;
};

void ProcessLight(Light light, ThreadInfo info) {
    float3 normal = Normal[info.dispatchId];
}

[numthreads(8, 8, 1)]
void LightingPass(ThreadInfo input) {
    const uint globalTileOffset = (input.id.y * TileCount.x + input.id.x) * TILE_BUCKET_COUNT;
    for (int i = input.index; i < TILE_BUCKET_COUNT; i++) {
        const uint lightsOffset = i * 32;
        uint bucket = AllTiles.Load(globalTileOffset + i);
        while (bucket != 0) {
            const uint firstLightIndex = firstbitlow(bucket);
            ClearBit(bucket, firstLightIndex);
            const Light light = Lights[lightsOffset + firstLightIndex];
            ProcessLight(light, input);
        }
    }
}